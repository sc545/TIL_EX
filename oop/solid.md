1. 단일 책임 원칙 (Single responsibility principle)

두문자 : S 약어 : SRP

모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다.(응집성을 높이고 결합도를 낮춘다.)

___ 클래스에 대한 SRP 분석

___ (이)가 자신을 ___ 한다.


2. 개방-폐쇄 원칙 (Open/closed principle)

두문자 : O 약어 : OCP

소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 프로그래밍 원칙이다.

- 확장에 대해 열려 있다.

이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.

- 수정에 대해 닫혀 있다

모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.

- 반복 금지의 원리 (DRY: Don't Repeat Yourself)
-> 공통되는 부분을 추출하여 추상화하고 한 곳에 두어 중복 코드를 피하라.


3. 리스코프 치환 원칙 (Liskov substitution principle)

두문자 : L 약어 : LSP

치환성(substitutability)은 객체 지향 프로그래밍 원칙이다. 컴퓨터 프로그램에서 자료형 S가 자료형 T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙이다.

자식 타입들은 부모 타입들이 사용되는 곳에 대체될 수 있어야 한다.

LSP는 잘 디자인된 상속에 관한 내용입니다. 부모 클래스를 상솔할 때, 부모 클래스가 사용되는 곳은 아무 문제없이 자식 클래스도 사용할 수 있어야 합니다.
그렇지 않으면, 상속을 잘못 사용하고 있는 것입니다.

상속의 대안들... (상속 외에도 다른 클래스의 행위를 재사용하는 방법들...)

※ 다른 클래스의 기능을 사용해야 하지만 그 기능을 변경(확장?)하고 싶지 않다면, 상속 대신 위임의 사용을 고려하세요.

- 위임 (Delegation)
-> 위임은 특정 일의 책임을 다른 클래스나 메소드에 맡길 때를 지칭합니다.


※ 가끔은 위임이 여러분이 필요로 하는 것이 아닐 수 있습니다. 위임에서는, 여러분이 위임하고 있는 객체의 기능이 변하지 않습니다. 하지만 어떤 경우에는, 여러 개의 행동 중 하나를 선택해야 합니다.

- 구성 (Composition)
-> 구성을 통해 하나의 인터페이스를 구현한 여러 클래스들의 기능을 사용할 수 있고 실행 중에 그 클래스를 바꾸어 기능을 변경할 수 있습니다.
-> 구성에서는, 다른 행동들로 구성된 객체는 그 행동을 소유하고 있는 것입니다. 그 객체가 없어지면, 소유하고 있던 모든 행동들도 없어집니다.
-> 구성에 참여한 행동들은 그 구성의 외부에서는 존재하지 않습니다.


※ 구성의 모든 이점(행동을 선택하고 LSP를 준수하는 것)이 필요하지만 구성에 참여한 객체들이 주 객체의 외부에서도 존재해야 한다면 어떻게 될까요? 이러한 경우 집합이 필요합니다.

- 집합 (Aggregation)
-> 집합은 한 클래스가 다른 클래스의 부분으로 사용되지만 다른 클래스의 외부에서도 여전히 존재하는 경우를 지칭합니다.


- 위임 -> 클래스의 행동을 변경하고 싶지 않고 그 행동을 스스로 구현하는 것이 그 클래스의 책임이 아닌 경우에는 그 행동을 다른 클래스에 위임하세요.

- 구성 -> 구성을 사용하여 하나 또는 여러 개의 클래스, 특히 비슷한 종류의 여러 클래스들로부터 행동을  재사용할 수 있습니다. 여러분의 객체가 다른 객체를 완전히 소유하고 있는 형태이며, 구성 관계로 연결된 객체는 여러분 객체의 외부에 독립적으로 존재할 수 없습니다.

- 집합 -> 구성 관계의 이점을 바라지만 여러분 객체의 외부에서도 연결된 객체의 행동이 사용되는 경우, 집합을 사용하세요.

-> 이 세 가지 객체지향 기법들을 이용해 LSP를 위반하지 않으면서 행동의 재사용이 가능해집니다.

※ 위임과 구성 그리고 집합을 상속보다 선호하면, 대개의 경우 여러분의 소프트웨어는 더 유연하고, 유지보수성, 확장성, 그리고 재사용성이 좀 더 좋아집니다.


이게 좀 헷갈린다.




4. 인터페이스 분리 원칙 (Interface segregation principle)

두문자 : I 약어 : ISP

인터페이스 분리 원칙은 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다. 이와 같은 작은 단위들을 역할 인터페이스라고도 부른다. 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.




5. 의존관계 역전 원칙 (Dependency inversion principle)

두문자 : D 약어 : DIP

객체 지향 프로그래밍에서 의존 관계 역전 원칙은 소프트웨어 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존 관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다. 이 원칙은 다음과 같은 내용을 담고 있다.

첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.

둘째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

이 원칙은 '상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다'는 객체 지향적 설계의 대원칙을 제공한다.

[출처] 객체지향 5원칙 SOLID|작성자 lhm0812
